<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="ElliottX4"><meta name="keywords" content="java"><meta name="description" content="互联网 技术 博客"><link rel="alternative" href="/atom.xml" title="NEVER NEVER NEVER" type="application/atom+xml"><link rel="icon" href="/alipay.png"><title>Java-定时任务 - NEVER NEVER NEVER</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">NEVER NEVER NEVER</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-02-21T14:34:26.000Z">2019 - 02 - 21</time><h1 class="post__title"><a href="/2019/02/21/java-定时任务/">Java-定时任务</a></h1><div class="post__main echo"><p>java目前常用的有三种定时任务</p>
<ol>
<li>JDK自带的Timer</li>
<li>spring的Task</li>
<li>Quartz<h3 id="一、Timer"><a href="#一、Timer" class="headerlink" title="一、Timer"></a>一、Timer</h3>Timer是jdk中提供的一个定时器工具，使用的时候会在主线程之外起一个单独的线程执行指定的计划任务，可以指定执行一次或者反复执行多次。<br>TimerTask是一个实现了Runnable接口的抽象类，代表一个可以被Timer执行的任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import java.util.Timer;</span><br><span class="line">import java.util.TimerTask;</span><br><span class="line"></span><br><span class="line">public class TimerTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        Timer timer = new Timer();</span><br><span class="line">        TimerTask timerTask = new TimerTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;当前时间&quot;);//具体的任务</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.schedule(timerTask1,1000,1000);//任务，开始时间ms，间隔ms</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);//不停两秒，显示不出来，因为test情况下当前用户线程结束，可是定时任务1s还没开始，就被终止</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="终止timer的方式"><a href="#终止timer的方式" class="headerlink" title="终止timer的方式"></a>终止timer的方式</h4><ul>
<li>调用timer的cancle方法，</li>
<li>把timer线程设置成daemon线程，（new Timer(true)创建daemon线程），在jvm里，如果所有用户线程结束，那么守护线程也会被终止，不过这种方法一般不用。</li>
<li>当所有任务执行结束后，删除对应timer对象的引用，线程也会被终止。</li>
<li>调用System.exit方法终止程序<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4></li>
<li>每一个Timer仅对应唯一一个线程。</li>
<li>Timer不保证任务执行的十分精确， schedule(<font color="#0075EA">如果某一次调度时间比较长，那么后面的时间会顺延</font>)和scheduleAtFixedRate(<font color="#0075EA">严格按照调度时间来的，如果某次调度时间太长了，那么会通过缩短间隔的方式保证下一次调度在预定时间执行</font>)会有不同的时间差。</li>
<li>Timer类的线程安全的</li>
<li>jdk1.5之后，ScheduledExecutorService代替了Timer来实现任务调度，加入了线程池等特性。<h3 id="二、spring的Task"><a href="#二、spring的Task" class="headerlink" title="二、spring的Task"></a>二、spring的Task</h3>Task底层的实现，使用的ScheduledExecutorService。<h4 id="注解形式"><a href="#注解形式" class="headerlink" title="注解形式"></a>注解形式</h4>使用@EnableScheduling启动定时任务注解解析，之后@Schedule写在执行的任务上即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">public class Task &#123;</span><br><span class="line"></span><br><span class="line">    @Scheduled(zone = &quot;Asia/Beijing&quot;,cron = &quot;0/10 * * * * * *&quot;)//zone表示时区</span><br><span class="line">    public void schedule4()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    fixedDelay对应的fixedDelayString支持字符串形式、占位符$&#123;&#125;|#&#123;&#125;</span><br><span class="line">     */</span><br><span class="line">    @Scheduled(fixedDelay = 5000)//上一次执行完毕时间点之后多长时间再执行</span><br><span class="line">    public void schedule1()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Scheduled(fixedRate = 5000)//上一次开始执行时间点之后多长时间再执行</span><br><span class="line">    public void schedule2()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Scheduled(initialDelay = 5000)//第一次延迟多长时间后再执行</span><br><span class="line">    public void schedule3()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://www.jianshu.com/p/1defb0f22ed1" target="_blank" rel="noopener">cron表达式详解</a></p>
<h4 id="直接代码"><a href="#直接代码" class="headerlink" title="直接代码"></a>直接代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TaskX80 &#123;</span><br><span class="line"></span><br><span class="line">    private static TaskScheduler taskScheduler = new ConcurrentTaskScheduler();//任务调度器</span><br><span class="line">    private static ScheduledFuture&lt;?&gt; scheduledFuture;//相当于每一个任务</span><br><span class="line">    private static Trigger trigger = new CronTrigger(&quot;0/10 * * * * *&quot;);</span><br><span class="line">    public static void startTask(int time) &#123;</span><br><span class="line">        scheduledFuture = taskScheduler.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //定时任务会早于自动注入，所以无法使用Autowired,需要自己手动获取</span><br><span class="line">                DeviceService deviceService = ApplicationContextUtils.getBean(DeviceService.class);//无法自动注入</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, time * 60 * 1000);</span><br><span class="line">        scheduledFuture.cancel(true);//停止任务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskScheduler的子类</p>
<ul>
<li>ConcurrentTaskScheduler：以当前线程执行任务。如果任务简单，可以直接使用这个类来执行。快捷方便。</li>
<li>DefaultManagedTaskScheduler：以当前线程执行任务，这是ConcurrentTaskScheduler的子类，添加了JNDI的支持。和ConcurrentTaskScheduler一样的用法，需要使用JNDI可以单独设置</li>
<li>ThreadPoolTaskScheduler：TaskScheduler接口的默认实现类，多线程定时任务执行。<font color="#0075EA">可以设置执行线程池数（默认一个线程），使用前必须得先调用initialize()【初始化方法】，有shutDown()方法，执行完后可以关闭线程</font>。</li>
<li>TimerManagerTaskScheduler:用于包装CommonJ中的TimerManager接口。在使用CommonJ进行调度时使用。(没有使用过)</li>
</ul>
<p><a href="https://blog.csdn.net/icarusliu/article/details/79531343" target="_blank" rel="noopener">详细博客解释</a></p>
<h3 id="三、Quartz"><a href="#三、Quartz" class="headerlink" title="三、Quartz"></a>三、Quartz</h3><p><a href="https://www.w3cschool.cn/quartz_doc/" target="_blank" rel="noopener">官方文档</a></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/work/">work</a></li><li class="post__tag__item"><a class="post__tag__link" href="/tags/java-basic/">java-basic</a></li></ul></footer></article></main><footer class="foot"><div class="foot-copy">&copy; 2018 - 2019 ElliottX4</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>