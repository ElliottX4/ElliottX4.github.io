<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="ElliottX4"><meta name="keywords" content="java"><meta name="description" content="互联网 技术 博客"><link rel="alternative" href="/atom.xml" title="NEVER NEVER NEVER" type="application/atom+xml"><link rel="icon" href="/alipay.png"><title> - NEVER NEVER NEVER</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">NEVER NEVER NEVER</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-04-19T13:55:39.478Z">2019 - 04 - 19</time><h1 class="post__title"><a href="/2019/04/19/db-redis-introduce/"></a></h1><div class="post__main echo"><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="1-数据格式"><a href="#1-数据格式" class="headerlink" title="1. 数据格式"></a>1. 数据格式<br></h3><p>string、list、set、sorted set、hash(相当于map)</p>
<h3 id="2-RESP-https-www-cnblogs-com-tommy-huang-p-6051577-html"><a href="#2-RESP-https-www-cnblogs-com-tommy-huang-p-6051577-html" class="headerlink" title="2. RESP(https://www.cnblogs.com/tommy-huang/p/6051577.html)"></a>2. RESP(<a href="https://www.cnblogs.com/tommy-huang/p/6051577.html" target="_blank" rel="noopener">https://www.cnblogs.com/tommy-huang/p/6051577.html</a>)<br></h3><p>redis客户端和服务端的通信协议，实现简单、快速解析、可读性好。</p>
<h3 id="3-数据的持久化-https-www-cnblogs-com-chenliangcl-p-7240350-html"><a href="#3-数据的持久化-https-www-cnblogs-com-chenliangcl-p-7240350-html" class="headerlink" title="3. 数据的持久化(https://www.cnblogs.com/chenliangcl/p/7240350.html)"></a>3. 数据的持久化(<a href="https://www.cnblogs.com/chenliangcl/p/7240350.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenliangcl/p/7240350.html</a>)<br></h3><p>两种持久化方式：<font color="#F8752D" size="4">aof</font>(appent-only-file原理是将Reids的操作日志以追加的方式写入文件),<font color="#F8752D" size="4">rdf</font>(原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化,覆盖)</p>
<h3 id="4-redis的架构模式"><a href="#4-redis的架构模式" class="headerlink" title="4. redis的架构模式"></a>4. redis的架构模式<br></h3><p>单机、主从复制、哨兵、集群(3.0之后版本支持redis-cluster集群，无中心)</p>
<h3 id="5-什么是一致性哈希算法？什么是哈希槽？"><a href="#5-什么是一致性哈希算法？什么是哈希槽？" class="headerlink" title="5. 什么是一致性哈希算法？什么是哈希槽？"></a>5. 什么是一致性哈希算法？什么是哈希槽？<br></h3><p>(<a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener">https://www.cnblogs.com/lpfuture/p/5796398.html</a>)<br><br>(<a href="https://blog.csdn.net/z15732621582/article/details/79121213" target="_blank" rel="noopener">https://blog.csdn.net/z15732621582/article/details/79121213</a>)</p>
<h3 id="6-缓存穿透"><a href="#6-缓存穿透" class="headerlink" title="6. 缓存穿透"></a>6. 缓存穿透<br></h3><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，<font color="#F8752D">就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力</font>。这就叫做缓存穿透。<br></p>
<p><font color="#ff0000"><strong>如何避免？</strong></font><br></p>
<ol>
<li>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。<br></li>
<li>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤<br><h3 id="7-缓存雪崩"><a href="#7-缓存雪崩" class="headerlink" title="7. 缓存雪崩"></a>7. 缓存雪崩<br></h3>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，<font color="#F8752D">请求会去后端查询，会给后端系统带来很大压力</font>。导致系统崩溃。<br><br><font color="#ff0000"><strong>如何避免？</strong></font><br></li>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。<br></li>
<li>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期<br></li>
<li>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀<br><h3 id="8-redis是否线程安全"><a href="#8-redis是否线程安全" class="headerlink" title="8. redis是否线程安全"></a>8. redis是否线程安全</h3></li>
<li>对于redis来说，是网络请求模块使用了单线程。所以不需要烤炉线程安全问题，其他子模块人额按时多线程。</li>
<li>网络模块采用单线程，避免了线程竞争，可以提高访问速率。</li>
<li>主从模式下的分布式，依赖多个redis是线程不安全的。<h3 id="9-redis内部实现"><a href="#9-redis内部实现" class="headerlink" title="9.redis内部实现"></a>9.redis内部实现</h3></li>
<li>使用单线程的IO复用模型，内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，支持原子操作，然后利用epoll的多路复用特性，io读取是非常快的。但是如果使用redis的排序、聚合等功能，由于单线程，会阻塞cpu。<h2 id="redis的使用场景"><a href="#redis的使用场景" class="headerlink" title="redis的使用场景"></a>redis的使用场景</h2><h3 id="1-作为分布式锁：自旋去加锁"><a href="#1-作为分布式锁：自旋去加锁" class="headerlink" title="1. 作为分布式锁：自旋去加锁"></a>1. 作为分布式锁：自旋去加锁</h3></li>
<li><p>加锁：过期时间设置放在一个redistemplat中，不加过期时间，可能会产生死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">boolean result = redisTemplate.execute(new RedisCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public Boolean doInRedis(RedisConnection connection)</span><br><span class="line">			throws DataAccessException &#123;</span><br><span class="line">		byte[] keyByte = rawKey(key);</span><br><span class="line">		byte[] valueByte = rawValue(value);</span><br><span class="line">		boolean result = connection.setNX(keyByte, valueByte);</span><br><span class="line">		//程序崩溃，也会产生死锁。</span><br><span class="line">		if(result &amp;&amp; timeout!=null &amp;&amp; timeUnit!=null)&#123;</span><br><span class="line">			final long rawTimeout = TimeoutUtils.toMillis(timeout, timeUnit);</span><br><span class="line">			try &#123;</span><br><span class="line">				return connection.pExpire(keyByte, rawTimeout);</span><br><span class="line">			&#125; catch (Exception var3) &#123;</span><br><span class="line">				return connection.expire(keyByte, TimeoutUtils.toSeconds(timeout, timeUnit));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>解锁:使用lua语言，可以保证原子性，否则在对比val成功之后，锁突然过期，另一个程序加上了同key的锁，就会误解锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void unlock(K key,V value)&#123;</span><br><span class="line">	String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">	DefaultRedisScript redisScript = new DefaultRedisScript();</span><br><span class="line">	redisScript.setScriptText(script);</span><br><span class="line">	redisTemplate.execute(redisScript,Collections.singletonList(key), Collections.singletonList(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-作为异步队列：很少，因为mq的性能更好"><a href="#2-作为异步队列：很少，因为mq的性能更好" class="headerlink" title="2. 作为异步队列：很少，因为mq的性能更好"></a>2. 作为异步队列：很少，因为mq的性能更好</h3><ol>
<li>利用redis中的list双向队列来处理。</li>
</ol>
</div></header></article></main><footer class="foot"><div class="foot-copy">&copy; 2018 - 2019 ElliottX4</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>