<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="ElliottX4"><meta name="keywords" content="java"><meta name="description" content="互联网 技术 博客"><link rel="alternative" href="/atom.xml" title="NEVER NEVER NEVER" type="application/atom+xml"><link rel="icon" href="/alipay.png"><title>Java-Synchronized关键字理解 - NEVER NEVER NEVER</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">NEVER NEVER NEVER</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-04-18T05:53:07.000Z">2019 - 04 - 18</time><h1 class="post__title"><a href="/2019/04/18/java-synchronized关键字理解/">Java-Synchronized关键字理解</a></h1><div class="post__main echo"><h2 id="1-synchronized作用在method上两种作用域"><a href="#1-synchronized作用在method上两种作用域" class="headerlink" title="1.synchronized作用在method上两种作用域"></a>1.synchronized作用在method上两种作用域</h2><ol>
<li><font color="#0075EA" size="4">synchronized aMethod(){}：</font>某个对象实例的范围，锁是该对象，如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法，普通方法不受影响，不同的对象实例的synchronized方法是不相干扰的</li>
<li><font color="#0075EA" size="4">synchronized static aMethod(){}：</font>是某个类的范围，锁是class的类对象，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。<h2 id="2-synchronized-不可以继承"><a href="#2-synchronized-不可以继承" class="headerlink" title="2.synchronized 不可以继承"></a>2.synchronized 不可以继承</h2></li>
<li>父类的方法加上synchronized只针对父类的实例方法有用，子类继承之后，方法为普通方法，需要显示指定<h2 id="3-synchronized-method-amp-block的区别"><a href="#3-synchronized-method-amp-block的区别" class="headerlink" title="3.synchronized method&amp;block的区别"></a>3.synchronized method&amp;block的区别</h2></li>
<li><font color="#0075EA" size="4">synchronized method：</font>等介于synchronized（this）此时的锁为类实例对象，也就解释了为什么不能同时访问这个对象中任何一个synchronized方法</li>
<li><font color="#0075EA" size="4">synchronized block：</font>锁为后面括号中的对象，这个锁和代码块的中内容没有关系，只要是锁没有释放，所有相同对象锁的代码块都不能执行。<h2 id="4-synchronized-是可重入锁"><a href="#4-synchronized-是可重入锁" class="headerlink" title="4.synchronized 是可重入锁"></a>4.synchronized 是可重入锁</h2></li>
<li>以下代码块不会产生死锁，证明了synchronized获得的对象锁是可重入的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void out2()&#123;</span><br><span class="line">        out2();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁。</p>
<h2 id="5-synchronized和Lock的对比"><a href="#5-synchronized和Lock的对比" class="headerlink" title="5.synchronized和Lock的对比"></a>5.synchronized和Lock的对比</h2><h4 id="1-synchronized何时释放锁"><a href="#1-synchronized何时释放锁" class="headerlink" title="1. synchronized何时释放锁"></a>1. synchronized何时释放锁</h4><ul>
<li>获取锁的线程执行完了该代码块，然后线程才会释放对锁的占有。</li>
<li>线程执行发生异常，此时JVM会让线程自动释放锁<h4 id="2-synchronized缺陷"><a href="#2-synchronized缺陷" class="headerlink" title="2. synchronized缺陷"></a>2. synchronized缺陷</h4></li>
<li>线程阻塞，其他线程只能等,无法中断等待的线程</li>
<li>通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的</li>
<li>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作<h4 id="3-java-util-concurrent-locks的介绍"><a href="#3-java-util-concurrent-locks的介绍" class="headerlink" title="3. java.util.concurrent.locks的介绍"></a>3. java.util.concurrent.locks的介绍</h4></li>
<li>获取锁：lock()、tryLock()、tryLock(long time, TimeUnit unit)，lockInterruptibly()</li>
<li>lockInterruptibly(): thread.interrupt()方法能够中断线程的等待过程</li>
<li>释放锁：unlock()</li>
<li>实现类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lock reentrantLock = new ReentrantLock();//可重入锁</span><br><span class="line">Lock reentrantLock = new ReentrantLock(true);//可设置为公平锁，等待时间最长的优先执行</span><br><span class="line">ReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();//内部分为读锁和写锁</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/work/">work</a></li><li class="post__tag__item"><a class="post__tag__link" href="/tags/java-basic/">java-basic</a></li><li class="post__tag__item"><a class="post__tag__link" href="/tags/keywords/">keywords</a></li></ul></footer></article></main><footer class="foot"><div class="foot-copy">&copy; 2018 - 2019 ElliottX4</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>